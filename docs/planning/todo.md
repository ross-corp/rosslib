# Features

Backlog of small tasks for nephewbot to pick off. Each item should be self-contained and implementable without external coordination.

## social

- [ ] Add reading goals. Create a `reading_goals` PocketBase collection (fields: `user` relation to users, `year` integer required, `target` integer required, `created` auto; unique constraint on `(user, year)`). API endpoints: `GET /me/goals` (list all goals), `PUT /me/goals/:year` (create or update goal for a year — body: `{target: 25}`), `GET /me/goals/:year` (returns goal + current progress by counting books with status "finished" and `date_read` in that year), `GET /users/:username/goals/:year` (public endpoint, respects privacy). The progress query should count `user_books` rows where the user has a "finished" tag value and `date_read` falls within the year. Frontend: goal card on user profile page showing "{X} of {Y} books read in {year}" with a progress bar. Settings page gets a "Reading goal" section where the user sets their annual target. Record a `goal_set` activity when a goal is created or updated.

- [ ] Add user mentions in thread comments. When a thread comment body contains `@username`, look up the mentioned user and create a `mention` notification (type `thread_mention`, title: "`{commenter}` mentioned you in a thread", body: truncated comment text, metadata: `{thread_id, comment_id, book_ol_id}`). Matching should be case-insensitive, only match existing usernames, and skip self-mentions. No DB schema changes needed — uses the existing `notifications` collection. Update `CreateThreadComment` in `threads.go` to scan the comment body with a regex like `@([a-zA-Z0-9_]+)`, look up each match in the users table, and fan out notifications. Frontend: mentions are displayed as links to the user's profile — update the comment rendering component to parse `@username` tokens and wrap them in `<Link href="/{username}">`.

- [ ] Add a "recommend to friend" feature. Create a `recommendations` PocketBase collection (fields: `sender` relation to users, `recipient` relation to users, `book` relation to books, `note` text optional, `status` select `pending`/`seen`/`dismissed`, `created` auto; unique constraint on `(sender, recipient, book)` — one recommendation per sender/recipient/book triple). API endpoints: `POST /me/recommendations` (body: `{username, book_ol_id, note?}` — creates recommendation + notification to recipient, records `sent_recommendation` activity), `GET /me/recommendations` (list received recommendations for current user, default `status=pending`), `PATCH /me/recommendations/:id` (update status to `seen` or `dismissed`). Notify the recipient with a `book_recommendation` notification ("`{sender}` recommended `{book_title}`"). Frontend: "Recommend" button on book detail pages opens a modal with a user search input and optional note field. Recommendations page at `/notifications` or a new `/recommendations` route shows received recommendations with book cover, sender name, note, and dismiss/add-to-library actions.

## stats & data

- [ ] Add detailed reading statistics endpoint. Create `GET /users/:username/stats` (public, respects privacy) that returns comprehensive reading analytics computed from `user_books` and `book_tag_values`. Response should include: `books_by_year` (array of `{year, count}` from `date_read` grouped by year), `books_by_month` (array of `{year, month, count}` for the current year), `average_rating` (across all rated books), `rating_distribution` (count per star 1-5), `total_books` (count of all user_books), `total_reviews` (count with non-empty review_text), `pages_read_this_year` (sum of `books.page_count` for books finished this year — JOIN through `user_books` → `books`), `longest_book` (title + page_count of highest page_count finished book), `shortest_book` (same for lowest). All queries should use the existing `user_books` table with JOINs to `books`, `book_tag_values`, and `tag_values` (for "finished" status detection). Frontend: dedicated `/[username]/stats` page showing the data as simple text/number cards (no charts library needed — use CSS bar charts like the genre ratings component does). Link from profile page's "Reading Stats" section header.

- [ ] Add a reading log / timeline view. Create `GET /users/:username/timeline?year=2026` (public, respects privacy) that returns books read in a given year grouped by month. Query: join `user_books` with `books` where the user has a "finished" tag value AND `date_read` falls in the requested year. Return `{year, months: [{month: 1, books: [{book_id, open_library_id, title, cover_url, rating, date_read}]}]}`. Sort books within each month by `date_read`. Frontend: `/[username]/timeline` page with a year selector dropdown and month-by-month sections, each showing a horizontal row of book covers (reuse `BookCoverRow`). Default to the current year. Empty months are omitted.

## moderation & safety

- [ ] Add content reporting. Create a `reports` PocketBase collection (fields: `reporter` relation to users, `content_type` select `review`/`thread`/`comment`/`link`, `content_id` text required, `reason` select `spam`/`harassment`/`inappropriate`/`other`, `details` text optional, `status` select `pending`/`reviewed`/`dismissed`, `reviewer` relation to users optional, `created` auto). API endpoints: `POST /reports` (auth required; body: `{content_type, content_id, reason, details?}`; prevents duplicate reports from same user on same content), `GET /admin/reports?status=pending` (moderator only; returns reports with reporter username and content preview), `PATCH /admin/reports/:id` (moderator only; update status to `reviewed` or `dismissed`, sets `reviewer`). Frontend: small flag icon on reviews, thread comments, and community links. Clicking opens a modal with reason dropdown and optional details textarea. Admin page gets a new "Reports" section (similar to Feedback section) showing pending reports with content preview, reporter info, and review/dismiss buttons.

- [ ] Add notification preferences. Create a `notification_preferences` PocketBase collection (fields: `user` relation to users unique, `new_publication` bool default true, `book_new_thread` bool default true, `book_new_link` bool default true, `book_new_review` bool default true, `review_liked` bool default true, `thread_mention` bool default true, `book_recommendation` bool default true). API endpoints: `GET /me/notification-preferences` (returns current prefs or defaults if no row exists), `PUT /me/notification-preferences` (upsert — only update provided fields). Before creating any notification, check the recipient's preferences and skip if that notification type is disabled. If no preferences row exists, all types default to enabled. Frontend: settings page gets a "Notification preferences" section with toggle switches for each notification type.

## data quality

- [ ] Add series metadata. Create a `series` PocketBase collection (fields: `name` text required, `open_library_id` text optional, `description` text optional, `created` auto; index on `name`) and a `book_series` PocketBase collection (fields: `book` relation to books, `series` relation to series, `position` number optional — the book's order in the series; unique constraint on `(book, series)`). API endpoints: `GET /books/:workId/series` (returns series the book belongs to with position), `GET /series/:seriesId` (returns series info + ordered book list with covers), `POST /books/:workId/series` (auth required; body: `{series_name, position?}` — finds or creates series by name, links book). When fetching book detail via `GET /books/:workId`, include a `series` array in the response if the book has series memberships. Frontend: on book detail pages, show series badge(s) below the title — e.g. "Book 3 in The Lord of the Rings" — linking to a `/series/:id` page that shows all books in order with covers and a progress indicator for the viewing user. Also add the series info on book covers in shelf grids as a small "#{position}" badge.

- [ ] Populate series data from Open Library during book lookup. When a book is fetched from Open Library (in `books.go` `GetBookDetail`), check the OL work response for a `subject_places`, `subjects`, or — more usefully — the `/works/{workId}/editions.json` entries for `series` fields, or query `/search.json?q=series:{title}` to find related works. A simpler approach: parse the OL work's `links` and `subject_people` for series indicators. If a series is detected, auto-create the `series` and `book_series` records. This is best-effort — not all OL works have series data. Log when series data is found vs. not for visibility into coverage.

## import improvements

- [ ] Add StoryGraph CSV import. StoryGraph exports use a different CSV format than Goodreads. Add `POST /me/import/storygraph/preview` and `POST /me/import/storygraph/commit` endpoints. StoryGraph CSV columns include: `Title`, `Authors`, `ISBN/UID`, `Format`, `Read Status` (to-read/currently-reading/read/did-not-finish), `Star Rating`, `Review`, `Tags`, `Read Dates` (may be a range like "2024/01/15-2024/02/20"). Reuse the same OL lookup chain as Goodreads import. Map StoryGraph statuses to the existing status tag system (to-read → want-to-read, currently-reading → currently-reading, read → finished, did-not-finish → dnf). StoryGraph tags should be imported as label tag keys. Frontend: add a "StoryGraph" tab on the import settings page alongside the existing Goodreads tab, reusing the same preview/configure/commit flow and `ImportForm` component structure.

## Pending PRs

<!-- nephewbot moves tasks here when it opens a PR. Move to docs/planning/completed.md after merging. -->
- [Add delete-all-data endpoint and settings UI](https://github.com/ross-corp/rosslib/pull/37) — DELETE /me/account/data removes all user data; settings page gets Danger Zone with typed confirmation
- [Add create/existing label options to import shelf mapping](https://github.com/ross-corp/rosslib/pull/38) — Goodreads import configure step gains "Create label" and "Add to existing label" actions alongside Tag and Skip
- [Add review likes](https://github.com/ross-corp/rosslib/pull/51) — Toggle like on reviews with heart icon, notifications, and activity recording
- [Add user blocking](https://github.com/ross-corp/rosslib/pull/52) — Block/unblock users with review/search/feed filtering and profile UI
